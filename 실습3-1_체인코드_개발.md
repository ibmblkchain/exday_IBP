# 실습3-1_체인코드_개발

## 실습 소개
- 이 실습의 목적은 GoLang 프로그래밍 언어로 어떻게 체인코드(chaincode) 를 작성하는지 알려주는 것입니다. 그리고 어떻게 테스트 및 배포(deploy) 하는지, 블록체인 네트워크에 배포된 체인코드와 어떻게 연동하는지 배울 것입니다. 마지막으로는 IBP 에 체인코드를 배포할 것입니다.
- Linux Ubuntu 16.04 기반의 서버가 각자에게 제공되어 있으며 해당 서버에는 Hyperledger Fabric v1.2 가 이미 설치되어 있습니다.
- 이 실습을 위해 추가적으로 필요한 파일 또는 소프트웨어는 없습니다. 즉 여러분이 원하는 환경에서 (예를 들면 집이나 AWS 나 회사나 아무데나) 실습을 진행할 수 있습니다. 다만 Ubuntu 16.04 외의 OS 에서는 검증되지 않았으므로 해당 버전을 다운로드 받아 실습하길 권고합니다. Fabric 은 v1.0 ~ v1.3 에 모두 호환됩니다.

# 섹션1. 체인코드 배포하고 테스트하기
- 이 섹션은 체인코드를 어떻게 설치하고 테스트하는지 전반적인 프로세스를 이해하기 위해 간략한 예제를 보여주는 것입니다. 따라서 우리 실습의 최종 목표인 구슬(Marbles) 애플리케이션 개발 과정과는 무관합니다.

## 1.1. 시작하기

다음 경로로 이동하십시오.

	cd ~/workspace/fabric-getting-started/release/samples/workshop/fabric-samples/first-network
다음 명령어를 수행하십시오.

	./byfn.sh -m up

다음과 같이 결과값이 보이기 시작하면
![](/doc_images/3-1/01.png)

Ctrl+c 를 눌러서 종료하십시오.
이 쉘 스크립트는 Hyperledger Fabric 콤포넌트를 생성하고, 두 개의 피어(peer) 를 생성하고, 단일 채널(channel) 에 가입까지 자동으로 시켜주었습니다. 즉 우리는 Local Hyperledger Fabric 테스트 환경에 체인코드를 설치하고 배포할 준비가 이미 된 것입니다.

다음 명령어를 수행하십시오.

	docker exec -it cli bash 

이 명령어는 cli 라는 이름의 도커 컨테이너에 접속하여 bash 명령어를 수행할 수 있는 터미널 창을 열어 줍니다. cli 컨테이너는 오더러(orderer), 피어(peer) 등 Fabric 의 주요한 콤포넌트들에게 명령을 내릴 수 있는 일종의 Command Line Interface 입니다.

설치(install), 초기화(instantiate), 트랜잭션 호출(invoke) 및 조회(query) 를 이 CLI 컨테이너를 통해 모두 실행할 수 있습니다. 어떤 이유로 CLI 컨테이너를 종료했다면(exit 로 빠져 나갔다면) 위 docker exec 명령어를 다시 수행하면 됩니다. 갓도커

CLI 는 다음과 같이 보여야 합니다.
![](/doc_images/3-1/02.png)

만약 “export | grep CORE_PEER” 라고 쳤을 때, configuration 정보를 나타내는 몇몇 변수들을 볼 수 있을 것입니다.

>CORE_PEER_LOCALMSPID=Org1MSP
>CORE_PEER_ADDRESS=peer0.org1.example.com:7051
>CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users>/Admin@org1.example.com/msp
>CORE_PEER_TLS_ENABLED="false"

우리는 하루라는, 짧은 실습 시간의 제약이 있기 때문에 Hyperledger Fabric 이 어떻게 동작하는지 또는 위 변수들이 무엇을 의미하는지에 대해서는 생략하겠습니다. 더 많은 정보를 얻고 싶다면 Fabric Documentation 을 보는 것이 가장 효율적입니다.

site: https://hyperledger-fabric.readthedocs.io/en/latest/getting_started.html  

## 1.2. 설치하기
체인코드를 peer 에 설치하기 위해서는 다음 명령어를 수행하십시오.  

	peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02

여기서 -p 옵션은 체인코드 소스의 path 를 의미하며, 우리는 chaincode_example02 디렉토리에 존재하는 chaincode_example02.go 를 설치할 것입니다. 해당 소스는 비트코인처엄 ‘자산의 거래’(자산의 소유권을 이전시키는) 만을 수행하는 간단한 로직을 갖고 있습니다.

만약 성공했다면, peer 는 아래와 같이 잘 완료되었다는 설치 로그를 출력할 것입니다.

**Installed remotely response:<status:200 payload:"OK" > **

![](/doc_images/3-1/03.png)

다시 복습해보면, 설치 명령어 문법은 일반적으로 아래와 같습니다.

	peer chaincode install -n <chaincode id> -v <version> -p <path to the code>

<chaincode id> 는 우리가 정하는 체인코드의 이름(identifier) 이며, 문자열입니다. 예를 들어 구슬 애플리케이션을 위한 체인코드를 설치한다면 ‘marble’ 등과 같이 지정할 것입니다. 체인코드를 호출할 때마다 우리는 이 id 를 제공해야 합니다. 왜냐하면 Fabric 에게 내가 어떤 체인코드를 호출할 것인지 알려줘야 하기 때문입니다.
(하나의 원장, 하나의 블록체인 환경에 두 개 이상의 체인코드가 존재할 수 있음)

<path to the code> 는 체인코드의 소스 경로입니다. 그런데 여기서 주의할 점은 ‘peer 컨테이너 내에서의’ 체인코드 소스 경로라는 점입니다.(OS가 아님)

docker-compose.yaml 파일을 보면 우리는 workshop/fabric-samples 에 존재하는 chaincode 디렉토리가 peer 도커 컨테이너에서는 github.com/hyperledger/fabric/examples/chaincode/go 경로로 마운트(mount) 되어 있음을 확인할 수 있습니다.

<version> 또한 제공되어야 합니다; 버전 정보는 숫자이며, 체인코드를 수정할 경우 다른 버전의 체인코드를 관리하기 위해서 필요합니다. 여기서 주의할 점은 한번 설치한 버전은 덮어쓰거나 삭제할 수 없습니다. 왜냐하면 체인코드 또한 블록체인 분산원장에 기록되는 하나의 정보이며, 이는 알다시피 원론적으로 수정/삭제가 불가능합니다.

## 1.3 초기화(Instantiating)

체인코드를 초기화한다는 것은 체인코드를 구동(run) 함을 의미합니다. 이는 해당 체인코드가 즉시 사용가능하며 호출가능하다는 것을 의미합니다. 이는 채널 단위의 명령어이기 때문에 (channel-wide), 하나의 peer 에만 수행하면 됩니다.

체인코드를 초기화하기 위해 다음 명령어를 수행하십시오.

	peer chaincode instantiate -o orderer.example.com:7050 -C mychannel -n mycc -v 1.0 -c '{"Args":["init","a","100","b","200"]}' -P "OR ('Org1MSP.member','Org2MSP.member')"

문법을 확인하면 다음과 같습니다.
*(이 명령어는 수행하지 마십시오)

peer chaincode instantiate -o <orderer address> -C <channel id> -n <chaincode id> -v <version string> -c <Init function arguments> -P <endorsement policy>

이 명령어는 완료되는데 약간의 시간이 소요될 수도 있습니다.
보증 정책(endorsement policies) 에 대한 자세한 정보는 여기를 참고하십시오:
https://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html

만약 정상적으로 초기화되었다면, 다음과 같이 009 리턴 코드가 출력될 것입니다.

![](/doc_images/3-1/04.png)

체인코드를 초기화할 때 가장 많이 하는 실수가 잘못된 version 정보를 기입하는 것입니다.
그리고 만약 체인코드 초기화에서 에러가 발생하여 실패하는 경우에 우리는 소스를 수정하여 설치(install) 부터 다시 진행해야 합니다. 그리고 설치 시에 version 정보는 새로운 버전 정보여야 합니다. 이 때문에 저는 v1.000 다음에는 v1.001 과 같이 아주 디테일하게..늘 에러가 나므로..

이러한 문제를 미리 방지하기 위해서는 자신이 짠 체인코드가 문법 상 오류가 없는지 미리 컴파일 해보는 것이 좋습니다. 방법은 자신의 체인코드가 존재하는 디렉토리에서 “go build” 명령어를 수행해 보면 됩니다.(or “go build --tags nopkcs11” depending on your setup) 이 명령어는 체인코드를 실행 가능한 파일로 컴파일 할 것이며(peer 에서 발생하는 프로세스와 동일) 이를 통해 우리는 소스 코드에 에러가 있는지 없는지 확인할 수 있습니다.

컴파일 후에 생성된 실행 파일은 rm 명령어로 반드시 삭제하십시오. 왜냐하면 Fabric 이 실행 파일까지 peer 에 업로드하려고 할 것이고 이는 결국 에러를 발생시킵니다.

##1.4 업데이트(수정)

체인코드를 업데이트하기 위해서는 먼저 새로운 버전의 체인코드를 설치(install) 해야 합니다. 이는 아까와 동일하게 install 명령어를 수행하면 됩니다. 단 version 정보는 기존보다 더 높게 설정하십시오.

	peer chaincode install -n mycc -v 1.1 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02

새 코드가 설치되면, upgrade 명령어를 통해 재배포가 가능합니다.

	peer chaincode upgrade -o orderer.example.com:7050 -C mychannel -n mycc -v 1.1 -c '{"Args":["invoke","a","10","b","3"]}'

![](/doc_images/3-1/05.png)

체인코드는 버전에 따라 각기 도커 컨테이너를 생성하여 구동되게 되는데, 체인코드를 업데이트하더라도 기존(old) 의 체인코드 컨테이너는 삭제되지 않습니다.

이를 확인하기 위해 ubuntu OS 커널 상에서docker ps 명령어를 수행해 보십시오. (CLI 컨테이너 내에서는 수행되지 않습니다)

이전 체인코드 컨테이너는 삭제하는 것을 추천하며, 그렇게 하는 것이 운영상 바람직합니다.

![](/doc_images/3-1/06.png)

아래와 같은 명령어로 컨테이너 삭제가 가능합니다.

	docker rm <container id of the previous chaincode> -f

##1.5 트랜잭션 호출 및 조회 (Invoking & Querying)

트랜잭션을 호출(Invoke) 및 조회(Query) 한다는 것은 체인코드와 통신(상호 작용) 한다는 것을 의미합니다.

호출(Invoke) 는 체인코드에게 원장 정보를 수정(또는 world state 를 수정) 하겠다는 요청입니다. 이는 테이터를 생성(Create), 수정(Update), 삭제(Delete) 하겠다는 것입니다.  

	peer chaincode invoke -o orderer.example.com:7050 -C mychannel -n mycc -c '{"Args":["invoke","a","b","5"]}'

호출은 성공 또는 실패 여부와 관계없이 기본적으로는 아무것도 리턴하지 않습니다. 아래를 보면 <result: 200 message: "OK"> 와 같이 결과값을 출력합니다. 이는 호출이 성공적이었다는 것을 알려줍니다.

![](/doc_images/3-1/07.png)

쿼리(Query) 는 체인코드를 통해 원장으로부터 데이터를 조회하고자 할 때 사용합니다.

	peer chaincode query -C mychannel -n mycc -c '{"Args":["query","a"]}'

쿼리는 일반적으로 JSON 포멧으로 데이터를 리턴하며, 또는 간단하게 문자열일 수도 있고 복잡한 데이터 구조를 가진 것일 수도 있습니다. 이는 체인코드 개발자가 해당 쿼리 함수의 return 값을 무엇으로 하느냐에 따라 다릅니다. 

![](/doc_images/3-1/08.png)

다음 섹션부터는 체인코드의 기본 구조를 설명하기 위해 하나씩 살펴보겠습니다.

# Section 2. 체인코드 소개 (Introduction to Chaincode)

## 2.1. 샘플 파일 열기

다음 파일을 여십시오.

	~/workspace/fabric-getting-started/release/samples/workshop/fabric-samples/chaincode/strings and open strings.go.

## 2.2 구조(Structure) 개요

### a.Imports



	




우리는 위의 값들을 설정하고, 사고 팔 수 있는(정확히는 주고 받을 수 있는) UI 를 만들어 블록체인의 원장에 저장할 예정입니다.
구슬(marble) 은 key와 value 쌍으로 이루어져 있으며,
`key`는 블록체인 원장에 구슬을 기록할 때 사용되는 고유한 구슬(자산) 의 ID 이고, `value`는 구슬(marble) 의 속성을 담고 있는 JSON 문자열입니다.
즉 위에서 나열되었던 4개의 데이터 속성이 모두 'value' 에 해당합니다.
체인코드(cc)는 gRPC 프로토콜을 이용하여 네트워크의 peer로 접속되어 상호작용합니다.
gRPC 프로토콜에 대한 상세 내용은 [Hyperledger Fabric Client](https://www.npmjs.com/package/fabric-client)라고 불리는 SDK에서 확인할 수 있습니다.
토폴로지에 대한 상세 내용은 아래 그림을 참고하십시오.

### 애플리케이션 통신 흐름

![](/doc_images/comm_flow.png)

1. 관리자는 브라우저에서 Node.js으로 구현된 애플리케이션을 통해 Marble들을 관리할 것입니다.
1. 이 클라이언트 측 JS 코드는 백엔드 Node.js 애플리케이션과 연결을 위한 websocket을 엽니다. 관리자가 사이트에서 액션을 취하면 클라이언트 측 JS 코드가 백엔드로 메시지를 보냅니다.
1. 원장(ledger)을 읽거나 쓰는 것은 제안(proposal)이란 방법을 이용하는데, 이 제안은 `Marbles`(SDK를 통해)에서 작성된 다음 블록체인 `Peer`로 전송(queries)됩니다.
1. `Peer`는 `Marbles`의 체인코드 컨테이너와 통신합니다. 체인코드가 트랜잭션을 실행 및 테스트(run/simulate)한 후, 만약 어떤 문제가 없다면 그 트랜잭션을 승인하고 그 결과를 `Marbles` 애플리케이션으로 돌려 보냅니다.
1. `Marbles` 애플리케이션은 (SDK를 통해) 승인된 제안을 `Ordering Service`로 보낼 것이며, orderer는 수신한 여러 제안을 블록으로 패키징 한 다음, 네트워크의 peer에 새 블록을 브로드캐스트 합니다.
1. 최종적으로 `Peer`는 블록의 유효성을 확인하고 원장에 기록합니다. 이제 제안을 통한 트랜잭션이 적용되었으며 이후의 모든 요청에 이러한 변경 사항이 반영됩니다.

***

# Marbles Setup
설치가 끝날 때쯤에는 당신은 Hyperledger Fabric 전문가가 될 것이고, 스스로 설계(design)한 애플리케이션을 개발할 준비가 될 것입니다.

구슬 애플리케이션은 크게 3가지의 독립적인 파트로 구성됩니다.
  1. 블록체인 네트워크 (GoLang)
  2. Server Side (node.js)
  3. Client Side (Javascript 및 node.js)

### 코드 구조
이 애플리케이션에는 조정할 수 있는 3가지 코딩 환경이 있습니다.

1. 체인코드 파트 - 블록체인 네트워크의 peer와 함께 실행되는 GoLang 코드입니다. 또한 `cc` 라고도 부릅니다. 모든 구슬/블록체인 거래는 궁극적으로 체인코드에서 이루어집니다. 이 파일들은 `/chaincode`에 저장되어 있습니다.

1. **클라이언트** 사이드 JS 파트 - 사용자 브라우저에서 실행 중인 JavaScript코드입니다. UI 상호 작용은 여기서 발생합니다. 이 파일들은 `/public/js`에 저장되어 있습니다.

1. **서버** 사이드 JS 파트 - 애플리케이션의 백엔드를 실행하는 JavaScript코드입니다. 즉, `Node.js` 코드는 Marbles 예제의 심장 역할을 하고 있으며 `node` 또는 `server` 코드 라고도 합니다. marble 관리자와 블록체인 사이를 연결해주는 역할을 합니다. 이 파일들은 `/utils` 와 `/routes`에 저장되어 있습니다.

이 세 파트는 서로 분리되어 있다는 것을 기억하세요.
각 파트는 변수나 기능을 공유하지 않으며, gRPC, WebSockets, 또는 HTTP와 같은 네트워킹 프로토콜로 각각 통신합니다.

우리는 IBP([IBM Blockchain Platform](https://console.bluemix.net/developer/blockchain/dashboard)) 네트워크를 활용하여 오늘 실습을 진행할 것입니다. IBP 가 Hyperledger Fabric 기반인 만큼 우리는 1번 파트(블록체인 네트워크) 를 자신의 on-prem 환경에 구축할 수도 있습니다. 둘다 장/단점이 존재하며 on-prem 구성은 숙제로 남겨두겠습니다. 기억할 점은 1번, 2번, 3번 파트는 모두 독립적인 파트이기 때문에 어떤 블록체인 네트워트를 사용하던 간에 2번, 3번 파트는 동일하게 진행하면 된다는 것입니다.
### 실습1. [개발환경 구성하기](./실습1_개발환경_구성하기.md)
**Git**과 **Go**, **Node.js**를 설치하기 위해 [개발환경 구성하기](./실습1_개발환경_구성하기.md) 에 따라 컴퓨터 환경을 세팅합니다.
우리가 오늘 실습에서 사용할 프로그래밍 언어는 크게 GoLang 및 Node.js 입니다. (안타깝게도 프로그래밍 언어에 대한 설명은 이번 실습에서 진행하지 않습니다ㅠㅠ)

또한 우리는 IBP 를 블록체인 네트워크로 사용할 것이므로 이에 대한 사전 작업이 필요합니다. IBM Cloud 계정을 생성하고, IBP 서비스 생성을 무료로 하기 위한 권한을 획득하는 과정 등을 진행할 것입니다.

<a name="downloadmarbles"></a>

### 1. 구슬(Marbles) 애플리케이션 다운로드
로컬환경에 Marbles을 다운로드 받아야 합니다.
Git을 사용하여 이 저장소를 내려받습니다 (clone).
IBM Cloud에서 Marbles을 호스팅 하려는 경우에도 이 단계를 수행해야 합니다.

- 명령 프롬프트/터미널을 열고 원하는 작업 디렉토리로 이동합니다.
- 다음 명령을 실행합니다:

	```
	git clone https://github.com/IBM-Blockchain/marbles.git --depth 1
	cd marbles
	```

- 좋습니다. 2단계로 넘어갑니다.

<a name="getnetwork"></a>

### 2. 네트워크 연결
[실습2. IBM Blockchain Platform 시작하기](./실습2_IBM_Blockchain_Platform_시작하기.md)
이제 우리는 블록체인 네트워크가 필요합니다.
IBM Cloud, IBM Blockchain Service에 네트워크 생성 - [지침](./docs/use_bluemix_hyperledger.md)

<a name="installchaincode"></a>

### 3. 체인코드 설치 및 인스턴스화
[실습3-1. 체인코드 개발하기](./실습3-1_체인코드_개발하기.md)
[실습3-2. 체인코드 설치하기](./실습3-2_체인코드_설치하기.md)

좋아요, 거의 다 왔어요! 이제 우리는 구슬 애플리케이션의 체인코드를 실행할 필요가 있어요.
체인코드는 궁극적으로 원장에서 트랜잭션을 만드는 중요한 요소라는 것을 기억하세요.
체인코드는 GoLang 으로 작성된 코드로 우리의 peer 위에 설치하고 채널에서 인스턴스화 할 필요가 있습니다.
코드는 이미 작성되어 있고, 우리는 단지 그것을 실행시키기만 하면 됩니다.

- **Option 1:** IBM Blockchain Service에 체인코드 설치 및 인스턴스화 - [지침](./docs/install_chaincode.md)

<a name="hostmarbles"></a>

### 구슬 애플리케이션 호스팅
[실습4-1. 애플리케이션 구동](./실습4-1_애플리케이션_구동.md)

마지막으로 중요한 것은 우리는 어딘가에 구슬(marbles) 애플리케이션이 실행될 곳이 필요하다는 것입니다.

**아래 옵션 한가지를 선택하세요:**
- **Option 2:** :lollipop: 로컬에서 Marbles 호스팅 - [지침](./docs/host_marbles_locally.md)

***

<a name="use"></a>

# 구슬 애플리케이션(Marbles) 사용하기
[실습5. 애플리케이션 사용](./실습5_애플리케이션_사용.md)

1. 이 단계에서는 환경 설정, 블록체인 네트워크 생성, marbles 앱 및 체인코드가 실행되고 있어야 합니다. 그렇죠? 그렇지 않다면 위에서 진행한 내용을 다시 확인해주세요.
1. 축하합니다. 이제 marbles 애플리케이션을 충분히 다룰 수 있습니다 :)!
이것이 마지막 단계였습니다.

	![](/doc_images/use_marbles1.png)

실습을 진행하기에 앞서 

# 블록체인 배경지식
Marbles의 작동 방식에 대해 이야기하기 전에 Hyperleder Fabric의 흐름과 토폴로지에 대해 살펴보겠습니다.
먼저 몇가지 정의부터 알아봅시다.

### 용어 정의:

**Peer** - Peer는 블록체인 네트워크의 멤버로, Hyperledger Fabric을 실행하고 있습니다. marbles 예제 맥락에서 보면, Peer들은 특정 구슬 회사에 의해 소유되고 운영됩니다.

**CA** - CA(인증 기관)는 블록체인 네트워크의 게이트키핑(gatekeeping)을 담당합니다. 이것은 marbles 예제의 node.js 애플리케이션과 같이, 클라이언트 측의 트랜잭션이 유효한지 증명합니다.

**Orderer** - Orderer 또는 Ordering Service는 블록에 트랜잭션을 묶어서 일괄 처리하는 것이 주 목적인 블록체인 네트워크의 멤버입니다.

**Users** - User는 블록체인과 상호 작용할 수 있는 권한을 가진 하나의 주체(entity)입니다. Marbles 예제에서, User는 관리자(Admin)를 뜻합니다. User는 원장을 조회하거나 가록할 수 있습니다.

**Blocks** - 블록에는 무결성을 확인하기 위한 트랜잭션과 해시(hash)가 포함되어 있습니다.

**Transactions** or **Proposals** - 블록체인의 원장에 대한 상호 작용을 나타냅니다. 원장의 읽기 또는 쓰기 요청은 트랜잭션 또는 제안의 형태로 보내집니다.

**Ledger** - Peer가 블록체인에서 사용하는 저장소(storage)입니다. 여기에는 트랜잭션 파라미터와 key/value 쌍으로 구성된 실제 블록 데이터가 포함됩니다. 원장(Ledger)은 체인코드에 의해 기록됩니다.

**Chaincode** - 체인코드는 스마트 컨트랙트를 Hyperledger Fabric에서 칭하는 용어입니다. 자산(assets) 및 자산과 관련된 모든 규칙을 정의합니다.

**Assets** - 자산은 원장이 가지는 가치 또는 실체(entity)입니다. key/value 쌍으로 이뤄져 있으며, marbles 예제에서 자산은 구슬(marble) 또는 구슬의 소유자입니다.


이제 여러분은 모든 흐름을 알게 되었습니다.
관리자는 구슬을 움직였고, JS는 drag/drop을 감지했으며, 클라이언트는 웹소켓 메시지를 보내고, Marbles 애플리케이션은 웹소켓 메시지를 받습니다. SDK는 제안을 생성하거나 보내고, Peer는 제안를 승인합니다. SDK 정렬하기 위한 제안을 Orderer에게 보냅니다, Orderer는 정렬(패키징)하여 생성된 블록을 Peer에게 보냅니다, Peer는 블록을 커밋 합니다. node.js 코드는 주기적으로 새로운 구슬 상태를 얻습니다, 새로운 구슬 상태를 클라이언트에게 전달하면, 마침내 웹소켓 메시지를 받은 클라이언트는 새로운 구슬을 다시 그리게 됩니다.

네, 끝입니다! 구슬을 옮기면서 즐거운 시간 보내셨기를 바랍니다.

# FAQs
marbles에 대해 궁금한점이 있으면..

# Feedback
피드백은 언제나 환영합니다.
이 데모는 여러분과 같은 사람들을 위해 만들어진 데모입니다. 그리고 계속해서 개선될 것입니다.
데모에 개선할 수 있는 방법이 있으면 손을 뻗어 도와주세요!
구체적인 내용은 아래와 같습니다:

# Contribute
이 데모의 개선에 기여를 원하신다면 [contributing guide](./CONTRIBUTING.md)를 확인해주세요.

# License
[Apache 2.0](LICENSE)

***



