# 실습3-1_체인코드_개발

## 실습 소개
- 이 실습의 목적은 GoLang 프로그래밍 언어로 어떻게 체인코드(chaincode) 를 작성하는지 알려주는 것입니다. 그리고 어떻게 테스트 및 배포(deploy) 하는지, 블록체인 네트워크에 배포된 체인코드와 어떻게 연동하는지 배울 것입니다. 마지막으로는 IBP 에 체인코드를 배포할 것입니다.
- Linux Ubuntu 16.04 기반의 서버가 각자에게 제공되어 있으며 해당 서버에는 Hyperledger Fabric v1.2 가 이미 설치되어 있습니다.
- 이 실습을 위해 추가적으로 필요한 파일 또는 소프트웨어는 없습니다. 즉 여러분이 원하는 환경에서 (예를 들면 집이나 AWS 나 회사나 아무데나) 실습을 진행할 수 있습니다. 다만 Ubuntu 16.04 외의 OS 에서는 검증되지 않았으므로 해당 버전을 다운로드 받아 실습하길 권고합니다. Fabric 은 v1.0 ~ v1.3 에 모두 호환됩니다.

# 섹션1. 체인코드 배포하고 테스트하기
- 이 섹션은 체인코드를 어떻게 설치하고 테스트하는지 전반적인 프로세스를 이해하기 위해 간략한 예제를 보여주는 것입니다. 따라서 우리 실습의 최종 목표인 구슬(Marbles) 애플리케이션 개발 과정과는 무관합니다.

## 1.1. 시작하기

다음 경로로 이동하십시오.

	cd ~/workspace/fabric-getting-started/release/samples/workshop/fabric-samples/first-network
다음 명령어를 수행하십시오.

	./byfn.sh -m up

다음과 같이 결과값이 보이기 시작하면
![](/doc_images/3-1/01.png)

Ctrl+c 를 눌러서 종료하십시오.
이 쉘 스크립트는 Hyperledger Fabric 콤포넌트를 생성하고, 두 개의 피어(peer) 를 생성하고, 단일 채널(channel) 에 가입까지 자동으로 시켜주었습니다. 즉 우리는 Local Hyperledger Fabric 테스트 환경에 체인코드를 설치하고 배포할 준비가 이미 된 것입니다.

다음 명령어를 수행하십시오.

	docker exec -it cli bash 

이 명령어는 cli 라는 이름의 도커 컨테이너에 접속하여 bash 명령어를 수행할 수 있는 터미널 창을 열어 줍니다. cli 컨테이너는 오더러(orderer), 피어(peer) 등 Fabric 의 주요한 콤포넌트들에게 명령을 내릴 수 있는 일종의 Command Line Interface 입니다.

설치(install), 초기화(instantiate), 트랜잭션 호출(invoke) 및 조회(query) 를 이 CLI 컨테이너를 통해 모두 실행할 수 있습니다. 어떤 이유로 CLI 컨테이너를 종료했다면(exit 로 빠져 나갔다면) 위 docker exec 명령어를 다시 수행하면 됩니다. 갓도커

CLI 는 다음과 같이 보여야 합니다.
![](/doc_images/3-1/02.png)

만약 “export | grep CORE_PEER” 라고 쳤을 때, configuration 정보를 나타내는 몇몇 변수들을 볼 수 있을 것입니다.

>CORE_PEER_LOCALMSPID=Org1MSP
>CORE_PEER_ADDRESS=peer0.org1.example.com:7051
>CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users>/Admin@org1.example.com/msp
>CORE_PEER_TLS_ENABLED="false"

우리는 하루라는, 짧은 실습 시간의 제약이 있기 때문에 Hyperledger Fabric 이 어떻게 동작하는지 또는 위 변수들이 무엇을 의미하는지에 대해서는 생략하겠습니다. 더 많은 정보를 얻고 싶다면 Fabric Documentation 을 보는 것이 가장 효율적입니다.

site: https://hyperledger-fabric.readthedocs.io/en/latest/getting_started.html  

## 1.2. 설치하기
체인코드를 peer 에 설치하기 위해서는 다음 명령어를 수행하십시오.  

	peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02

여기서 -p 옵션은 체인코드 소스의 path 를 의미하며, 우리는 chaincode_example02 디렉토리에 존재하는 chaincode_example02.go 를 설치할 것입니다. 해당 소스는 비트코인처엄 ‘자산의 거래’(자산의 소유권을 이전시키는) 만을 수행하는 간단한 로직을 갖고 있습니다.

만약 성공했다면, peer 는 아래와 같이 잘 완료되었다는 설치 로그를 출력할 것입니다.

**Installed remotely response:<status:200 payload:"OK" > **

![](/doc_images/3-1/03.png)

다시 복습해보면, 설치 명령어 문법은 일반적으로 아래와 같습니다.

	peer chaincode install -n <chaincode id> -v <version> -p <path to the code>

<chaincode id> 는 우리가 정하는 체인코드의 이름(identifier) 이며, 문자열입니다. 예를 들어 구슬 애플리케이션을 위한 체인코드를 설치한다면 ‘marble’ 등과 같이 지정할 것입니다. 체인코드를 호출할 때마다 우리는 이 id 를 제공해야 합니다. 왜냐하면 Fabric 에게 내가 어떤 체인코드를 호출할 것인지 알려줘야 하기 때문입니다.
(하나의 원장, 하나의 블록체인 환경에 두 개 이상의 체인코드가 존재할 수 있음)

<path to the code> 는 체인코드의 소스 경로입니다. 그런데 여기서 주의할 점은 ‘peer 컨테이너 내에서의’ 체인코드 소스 경로라는 점입니다.(OS가 아님)

docker-compose.yaml 파일을 보면 우리는 workshop/fabric-samples 에 존재하는 chaincode 디렉토리가 peer 도커 컨테이너에서는 github.com/hyperledger/fabric/examples/chaincode/go 경로로 마운트(mount) 되어 있음을 확인할 수 있습니다.

<version> 또한 제공되어야 합니다; 버전 정보는 숫자이며, 체인코드를 수정할 경우 다른 버전의 체인코드를 관리하기 위해서 필요합니다. 여기서 주의할 점은 한번 설치한 버전은 덮어쓰거나 삭제할 수 없습니다. 왜냐하면 체인코드 또한 블록체인 분산원장에 기록되는 하나의 정보이며, 이는 알다시피 원론적으로 수정/삭제가 불가능합니다.

## 1.3 초기화(Instantiating)

체인코드를 초기화한다는 것은 체인코드를 구동(run) 함을 의미합니다. 이는 해당 체인코드가 즉시 사용가능하며 호출가능하다는 것을 의미합니다. 이는 채널 단위의 명령어이기 때문에 (channel-wide), 하나의 peer 에만 수행하면 됩니다.

체인코드를 초기화하기 위해 다음 명령어를 수행하십시오.

	peer chaincode instantiate -o orderer.example.com:7050 -C mychannel -n mycc -v 1.0 -c '{"Args":["init","a","100","b","200"]}' -P "OR ('Org1MSP.member','Org2MSP.member')"

문법을 확인하면 다음과 같습니다.
*(이 명령어는 수행하지 마십시오)

peer chaincode instantiate -o <orderer address> -C <channel id> -n <chaincode id> -v <version string> -c <Init function arguments> -P <endorsement policy>

이 명령어는 완료되는데 약간의 시간이 소요될 수도 있습니다.
보증 정책(endorsement policies) 에 대한 자세한 정보는 여기를 참고하십시오:
https://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html

만약 정상적으로 초기화되었다면, 다음과 같이 009 리턴 코드가 출력될 것입니다.

![](/doc_images/3-1/04.png)

체인코드를 초기화할 때 가장 많이 하는 실수가 잘못된 version 정보를 기입하는 것입니다.
그리고 만약 체인코드 초기화에서 에러가 발생하여 실패하는 경우에 우리는 소스를 수정하여 설치(install) 부터 다시 진행해야 합니다. 그리고 설치 시에 version 정보는 새로운 버전 정보여야 합니다. 이 때문에 저는 v1.000 다음에는 v1.001 과 같이 아주 디테일하게..늘 에러가 나므로..

이러한 문제를 미리 방지하기 위해서는 자신이 짠 체인코드가 문법 상 오류가 없는지 미리 컴파일 해보는 것이 좋습니다. 방법은 자신의 체인코드가 존재하는 디렉토리에서 “go build” 명령어를 수행해 보면 됩니다.(or “go build --tags nopkcs11” depending on your setup) 이 명령어는 체인코드를 실행 가능한 파일로 컴파일 할 것이며(peer 에서 발생하는 프로세스와 동일) 이를 통해 우리는 소스 코드에 에러가 있는지 없는지 확인할 수 있습니다.

컴파일 후에 생성된 실행 파일은 rm 명령어로 반드시 삭제하십시오. 왜냐하면 Fabric 이 실행 파일까지 peer 에 업로드하려고 할 것이고 이는 결국 에러를 발생시킵니다.

## 1.4 업데이트(수정)

체인코드를 업데이트하기 위해서는 먼저 새로운 버전의 체인코드를 설치(install) 해야 합니다. 이는 아까와 동일하게 install 명령어를 수행하면 됩니다. 단 version 정보는 기존보다 더 높게 설정하십시오.

	peer chaincode install -n mycc -v 1.1 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02

새 코드가 설치되면, upgrade 명령어를 통해 재배포가 가능합니다.

	peer chaincode upgrade -o orderer.example.com:7050 -C mychannel -n mycc -v 1.1 -c '{"Args":["invoke","a","10","b","3"]}'

![](/doc_images/3-1/05.png)

체인코드는 버전에 따라 각기 도커 컨테이너를 생성하여 구동되게 되는데, 체인코드를 업데이트하더라도 기존(old) 의 체인코드 컨테이너는 삭제되지 않습니다.

이를 확인하기 위해 ubuntu OS 커널 상에서docker ps 명령어를 수행해 보십시오. (CLI 컨테이너 내에서는 수행되지 않습니다)

이전 체인코드 컨테이너는 삭제하는 것을 추천하며, 그렇게 하는 것이 운영상 바람직합니다.

![](/doc_images/3-1/06.png)

아래와 같은 명령어로 컨테이너 삭제가 가능합니다.

	docker rm <container id of the previous chaincode> -f

## 1.5 트랜잭션 호출 및 조회 (Invoking & Querying)

트랜잭션을 호출(Invoke) 및 조회(Query) 한다는 것은 체인코드와 통신(상호 작용) 한다는 것을 의미합니다.

호출(Invoke) 는 체인코드에게 원장 정보를 수정(또는 world state 를 수정) 하겠다는 요청입니다. 이는 테이터를 생성(Create), 수정(Update), 삭제(Delete) 하겠다는 것입니다.  

	peer chaincode invoke -o orderer.example.com:7050 -C mychannel -n mycc -c '{"Args":["invoke","a","b","5"]}'

호출은 성공 또는 실패 여부와 관계없이 기본적으로는 아무것도 리턴하지 않습니다. 아래를 보면 <result: 200 message: "OK"> 와 같이 결과값을 출력합니다. 이는 호출이 성공적이었다는 것을 알려줍니다.

![](/doc_images/3-1/07.png)

쿼리(Query) 는 체인코드를 통해 원장으로부터 데이터를 조회하고자 할 때 사용합니다.

	peer chaincode query -C mychannel -n mycc -c '{"Args":["query","a"]}'

쿼리는 일반적으로 JSON 포멧으로 데이터를 리턴하며, 또는 간단하게 문자열일 수도 있고 복잡한 데이터 구조를 가진 것일 수도 있습니다. 이는 체인코드 개발자가 해당 쿼리 함수의 return 값을 무엇으로 하느냐에 따라 다릅니다. 

![](/doc_images/3-1/08.png)

다음 섹션부터는 체인코드의 기본 구조를 설명하기 위해 하나씩 살펴보겠습니다.

# Section 2. 체인코드 소개 (Introduction to Chaincode)

## 2.1. 샘플 파일 열기

다음 파일을 여십시오.

	~/workspace/fabric-getting-started/release/samples/workshop/fabric-samples/chaincode/strings and open strings.go.

## 2.2 구조(Structure) 개요

### a.Imports

GoLang 올 짜여진 체인코드는 다음 첫 문장으로 시작됩니다.

import (
  "github.com/hyperledger/fabric/core/chaincode/shim"
  pb "github.com/hyperledger/fabric/protos/peer"
)

기본적인 imports 는 shim 및 Peer Response 의 정의를 포함하고 있습니다. shim 은 우리가 호출하는 API call 을 peer 가 이해할 수 있도록 변환해 주는 라이브러리입니다. Peer Response 는 성공/실패 이벤트로부터 트리거된 값을 peer 로부터 되돌려 받는 데이터 구조(Structure) 입니다.

### b. Struct

type StringsChaincode struct {
}

shim 은 Init() 함수 및 Invoke() 함수와 함께 체인코드가 하나의 object 로 구조화되길 바라며, 이러한 목적 때문에 빈 껍데기의 구조체 object 을 생성합니다.

### c. Main

func main() {
  err := shim.Start(new(StringsChaincode))
  if err != nil {
    fmt.Printf("Error starting Strings: %s", err)
  }
}

main 함수는 코드가 실행되면shim 에게 체인코드 instance 가 새로 생성되었음을 알려줍니다. 다른 말로 b. 에서 정의한 struct 가 생성되었다는 뜻입니다.

### d. Init()

func (t *StringsChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {

    // Declare variable
    fmt.Printf("Declaring")
    key := "Test"
    value := "Hello, World!"

    // Place into world state
    fmt.Printf("PutState")
    stub.PutState(key, []byte(value))

    // Exit with success
    return shim.Success(nil)
}

Init 함수는 코드가 초기화될 때 호출됩니다. (그리고 Init 함수를 수정했을 때 다시 호출되기도 함)
Init is called when the code is instantiated and again whenever it is updated.

위에서 보면 테스트용 초기값이 설정되어 있습니다. 지금이야 괜찮지만 블록체인의 불가역성을 생각해본다면 이를 추천하지는 않습니다. 한번 원장에 기록되면 다시 리셋할 수가 없기 때문입니다. 

### e. Invoke()

func (t *StringsChaincode) read(stub shim.ChaincodeStubInterface, args []string) pb.Response {
    valueAsBytes, _ := stub.GetState(args[0])
    return shim.Success(valueAsBytes)
}

func (t *StringsChaincode) overwrite(stub shim.ChaincodeStubInterface, args []string) pb.Response {
    stub.PutState(args[0], []byte(args[1]))
    return shim.Success(nil)
}

func (t *StringsChaincode) append(stub shim.ChaincodeStubInterface, args []string) pb.Response {
    oldValueAsBytes, _ := stub.GetState(args[0])
    var newValue bytes.Buffer
    newValue.Write(oldValueAsBytes)
    newValue.WriteString(args[1])
    stub.PutState(args[0], newValue.Bytes())
    return shim.Success(nil)
}

func (t *StringsChaincode) delete(stub shim.ChaincodeStubInterface, args []string) pb.Response {
    stub.DelState(args[0])
    return shim.Success(nil)
}

func (t *StringsChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {

    // Grab the inputs to the transaction
    function, args := stub.GetFunctionAndParameters()
    fmt.Println("invoke has been called with", function, "and", args)

    // Call the apropriate function
    if function == "read" {
        return t.read(stub, args)
    } else if function == "overwrite" {
        return t.overwrite(stub, args)
    } else if function == "append" {
        return t.append(stub, args)
    } else if function == "delete" {
        return t.delete(stub, args)
    }

    // If 'function' doesn't match any of the above then return an error
    return shim.Error("Invalid invoke function name.")
}

Invoke 함수는 user 가 트랜잭션 호출(invoke) 또는 조회(query) 요청을 발생시키는 경우 호출되는 함수입니다. (사실상 맨날 호출)

일반적인 구조는 트랜잭션들을 이름에 따라 분기하기 위한 if 문 세트를 가지는 것입니다. 즉 트랜잭션들을 종류별로 일종의 routing 하기 위함입니다.

조회 성(query) 트랜잭션을 ‘Invoke’ 함수에 포함시키는 것이 가능한 것으로 보이지만, 실제로는 이러한 query 만을 수행하는 함수는 invoke 역할을 수행하지 않습니다. 즉 우리는 함수를 분기하기 위해 ‘Invoke’ 함수 내의 if문에 호출(query) 함수를 포함시키는 것일 뿐이라는 점을 기억해 주십시오.

## 2.3. Using Strings

### a. Install

Strings 체인코드를 설치하기 위해 다음 명령어르 수행하십시오.

	peer chaincode install -n strings -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/strings

### b. Instantiate

Strings 체인코드를 초기화하기 위해 다음 명령어를 수행하십시오.

	peer chaincode instantiate -o orderer.example.com:7050 -C mychannel -n strings -v 1.0 -c '{"Args":["init"]}' -P "OR ('Org1MSP.member','Org2MSP.member')"

### c. Query

현재 상태를 조회(Query) 하십시오. ‘Hello, World’ 가 출력되어야 합니다.

	peer chaincode query -C mychannel -n strings -c '{"Args":["read", "Test"]}'

![](/doc_images/3-1/09.png)

### d. Invoke

이제 값을 수정해 보겠습니다. Lorem Ipsum 라는 값으로 치환하세요.

	peer chaincode invoke -o orderer.example.com:7050 -C mychannel -n strings -c '{"Args":["overwrite", "Test", "Lorem Ipsum"]}'

![](/doc_images/3-1/10.png)

### e. Invoke 가 정상적으로 되었는지 확인

조회(query) 명령어를 다시 수행해서 분산 원장의 값이 정상적으로 변경되었는지 확인하십시오.

	peer chaincode query -C mychannel -n strings -c '{"Args":["read", "Test"]}'

응답은 "Lorem Ipsum" 여야 합니다. (다른 값을 넣으신 분은 다른 값이 나와야겠져?)

![](/doc_images/3-1/11.png)

### f. More Invokes

‘strings.go’ 파일을 열어서 append() 함수 및 delete() 함수가 어떻게 작성되어 있는지 공부해 보시기 바랍니다. 그리고 아래와 같이 append() 함수를 호출해 보십시오.

	peer chaincode invoke -o orderer.example.com:7050 -C mychannel -n strings -c '{"Args":["append", "Test", "Delor Semat"]}'

결과가 어떻나요? 아래와 같은 결과가 나와야 정상입니다:

![](/doc_images/3-1/12.png)

이번에는 delete() 함수를 사용하여 “Test” 를 삭제해 보십시오. 명령어는 과제로 맡기겠습니다. 

![](/doc_images/3-1/13.png)


# Section 2. 구슬(Marbles) 체인코드 개발하기

이번 섹션에서 우리는 방금 테스트하였던 Strings 체인코드와 비슷하게 직접 체인코드를 작성할 것입니다. 이 실습에서 우리는 코드 기반으로 단순하게 정의하였던 데이터(data) 를 구조체(structures) 기반으로 바꿀 것입니다. 왜냐하면 왠만한 데이터는 그 속성을 하나만 가지지는 않기 때문입니다. 즉 ‘key’ 에 대응하는 ‘value’ 는 일반적으로 많은 값을 담을 수 있는 형태를 가집니다. GoLang 에서는 이를 구조체(Structure) 자료형으로 담습니다.
이 체인코드 역시 GoLang 으로 작성될 것이며, 이 코드는 오늘 실습의 블록체인 기반 애플리케이션에서 직접 사용될 코드입니다.
GoLang 에 대한 자세한 내용은 여기를 참고하십시오:  [요기요](https://gobyexample.com/)

## 3.1. 기본 파일 생성

다음 명령어를 수행하여 디렉토리를 이동합니다.

	cd ~/workspace/fabric-getting-started/release/samples/workshop/fabric-samples/chaincode 

‘marbles’ 라는 이름으로 새 디렉토리를 생성하십시오. 그리고 skeleton.go 파일을 복사하여 해당 디렉토리에 copy 하십시오. Skeleton.go 의 경로는 아래와 같습니다.

	~/workspace/fabric-getting-started/release/samples/workshop/fabric-samples/chaincode/skeleton

그리고 skeleton.go 파일을 marbles.go 파일로 rename 하십시오. 우리는 이 파일을 오늘 실습의 블록체인 체인코드로 사용할 것입니다.

이 skeleton 코드는 Hyperledger Fabric 의 GoLang 체인코드의 기본 구조를 가지고 있습니다. 우리는 먼저 strings.go 체인코드와 비슷한 코드를 작성하면서 시작해 볼까 합니다.
그리고 나서는 데이터 형식을 좀더 현실적인 구조로 바꿀 것입니다.

Visual Studio Code 는(VS Code) 는 Go 플러그인을 가지고 있어서 자동으로 dependencies(종속성) 문제를 감지해주며, import 해주기도 합니다. 먼저 import statement 구문에 추가되어 있는 라이브러리들이 정상적인지 체크를 하여 컴파일 에러가 있다면 에러를 발생시켜 줄 것입니다.

>"encoding/json" - Handles un/marshalling complex data structures
>"fmt" - Roughly akin to stdio in C 
>"strconv" - String conversion library

## 3.2. Storing Basic Data

### a. Adding Data
Init 함수를 살펴보겠습니다. 먼저 체인코드가 초기화될 때key 값 및 문자열 value 를 저장하는 코드를 추가하십시오. 

func (t *Chaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {
	stub.PutState("Test", []byte("Hello, World!"))
	return shim.Success(nil)
}

Hyperledger Fabric 은 데이터를 Key/Value 쌍으로 저장한다고 육백팔십다섯번 애기했습니다. Key 를 저장하기 위해 shim 의 PutState 메소드를 사용하십시오. Key 부문은 문자열(string) 로, value 부문은 바이트배열([]byte) 로 표현되도록 합니다.

>stub.PutState(<key>, <value>)

### b. Reading data

Invoke 함수 위에 read() 라는 새로운 함수를 추가하십시오.

func (t *Chaincode) read(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	valueAsBytes, _ := stub.GetState(args[0])
	return shim.Success(valueAsBytes)
}

분산 원장(정확히는 world state) 으로부터 데이터를 검색(Retrieving) 할 때는 shim 의 GetState 메소드를 사용합니다.

buffer, errorBuffer := stub.GetState(args[0])

이것은 buffer 형태로 데이터를 받아들이고, 만약 에러가 발생하면 ‘errorBuffer’ Object 에 에러를 저장합니다. 데이터를 바이트 배열(byte array) 포맷으로 변환하지 않은 점을 기억하십시오. shim 은 자체적으로 argument 로서 byte array 를 받아들이기 때문에 우리는 그저 간단하게 이것을 전달하기만 하면 됩니다. 즉 직접 변환할 필요가 없습니다. 

이제 Invoke 함수를 업데이트할 차례입니다. 현재 시점에서 read 함수를 작성하는 것은 아니고 Invoke 가 발생했을 때 특정 쿼리 함수로 라우팅해주는 코드를 먼저 작성합니다. 여기서는 read 함수로 라우팅하는 예제가 되겠죠. 

func (t *Chaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {
	function, args := stub.GetFunctionAndParameters()
	if function == "read" {
		return t.read(stub, args)
	}
	return shim.Error("Invalid invoke function name.")
}

이제 “read” 요청이 발생했다고 가정하면, invoke 가 호출될 것이고 invoke 함수는 read 함수를 다시 호출할 것입니다.

c. Testing read

도커 CLI 커맨드라인에서 우리가 방금 만들었던 코드를 deploy 하십시오.

	peer chaincode install -n marbles -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/marbles
	peer chaincode instantiate -o orderer.example.com:7050 -C mychannel -n marbles -v 1.0 -c '{"Args":["init"]}' -P "OR ('Org1MSP.member','Org2MSP.member')"

read 쿼리문을 수행하십시오.

	peer chaincode query -C mychannel -n marbles -c '{"Args":["read", "Test"]}'

만약 성공한다면, Init 에 코딩했던 “Hello World” 문자열이 출력되어야 합니다.

![](/doc_images/3-1/14.png)
	
































