# 실습3-1_체인코드_개발

## 실습 소개
- 이 실습의 목적은 GoLang 프로그래밍 언어로 어떻게 체인코드(chaincode) 를 작성하는지 알려주는 것입니다. 그리고 어떻게 테스트 및 배포(deploy) 하는지, 블록체인 네트워크에 배포된 체인코드와 어떻게 연동하는지 배울 것입니다. 마지막으로는 IBP 에 체인코드를 배포할 것입니다.
- Linux Ubuntu 16.04 기반의 서버가 각자에게 제공되어 있으며 해당 서버에는 Hyperledger Fabric v1.2 가 이미 설치되어 있습니다.
- 이 실습을 위해 추가적으로 필요한 파일 또는 소프트웨어는 없습니다. 즉 여러분이 원하는 환경에서 (예를 들면 집이나 AWS 나 회사나 아무데나) 실습을 진행할 수 있습니다. 다만 Ubuntu 16.04 외의 OS 에서는 검증되지 않았으므로 해당 버전을 다운로드 받아 실습하길 권고합니다. Fabric 은 v1.0 ~ v1.3 에 모두 호환됩니다.

# 섹션1. 체인코드 배포하고 테스트하기
- 이 섹션은 체인코드를 어떻게 설치하고 테스트하는지 전반적인 프로세스를 이해하기 위해 간략한 예제를 보여주는 것입니다. 따라서 우리 실습의 최종 목표인 구슬(Marbles) 애플리케이션 개발 과정과는 무관합니다.

## 1.1.	

다음 경로로 이동하십시오.

	cd ~/workspace/fabric-getting-started/release/samples/workshop/fabric-samples/first-network

다음 명령어를 수행하십시오.

	./byfn.sh -m up

다음과 같이 결과값이 보이기 시작하면
![](/doc_images/3-1/01.png)

Ctrl+c 를 눌러서 종료하십시오.

이 쉘 스크립트는 Hyperledger Fabric 콤포넌트를 생성하고, 두 개의 피어(peer) 를 생성하고, 단일 채널(channel) 에 가입까지 자동으로 시켜주었습니다. 즉 우리는 Local Hyperledger Fabric 테스트 환경에 체인코드를 설치하고 배포할 준비가 이미 된 것입니다.

다음 명령어를 수행하십시오.

	docker exec -it cli bash 

이 명령어는 cli 라는 이름의 도커 컨테이너에 접속하여 bash 명령어를 수행할 수 있는 터미널 창을 열어 줍니다. cli 컨테이너는 오더러(orderer), 피어(peer) 등 Fabric 의 주요한 콤포넌트들에게 명령을 내릴 수 있는 일종의 Command Line Interface 입니다.

설치(install), 초기화(instantiate), 트랜잭션 호출(invoke) 및 조회(query) 를 이 CLI 컨테이너를 통해 모두 실행할 수 있습니다. 어떤 이유로 CLI 컨테이너를 종료했다면(exit 로 빠져 나갔다면) 위 docker exec 명령어를 다시 수행하면 됩니다. 갓도커

CLI 는 다음과 같이 보여야 합니다.
![](/doc_images/3-1/02.png)

만약 “export | grep CORE_PEER” 라고 쳤을 때, configuration 정보를 나타내는 몇몇 변수들을 볼 수 있을 것입니다.

>CORE_PEER_LOCALMSPID=Org1MSP
>CORE_PEER_ADDRESS=peer0.org1.example.com:7051
>CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users>/Admin@org1.example.com/msp
>CORE_PEER_TLS_ENABLED="false"




	

우리는 위의 값들을 설정하고, 사고 팔 수 있는(정확히는 주고 받을 수 있는) UI 를 만들어 블록체인의 원장에 저장할 예정입니다.
구슬(marble) 은 key와 value 쌍으로 이루어져 있으며,
`key`는 블록체인 원장에 구슬을 기록할 때 사용되는 고유한 구슬(자산) 의 ID 이고, `value`는 구슬(marble) 의 속성을 담고 있는 JSON 문자열입니다.
즉 위에서 나열되었던 4개의 데이터 속성이 모두 'value' 에 해당합니다.
체인코드(cc)는 gRPC 프로토콜을 이용하여 네트워크의 peer로 접속되어 상호작용합니다.
gRPC 프로토콜에 대한 상세 내용은 [Hyperledger Fabric Client](https://www.npmjs.com/package/fabric-client)라고 불리는 SDK에서 확인할 수 있습니다.
토폴로지에 대한 상세 내용은 아래 그림을 참고하십시오.

### 애플리케이션 통신 흐름

![](/doc_images/comm_flow.png)

1. 관리자는 브라우저에서 Node.js으로 구현된 애플리케이션을 통해 Marble들을 관리할 것입니다.
1. 이 클라이언트 측 JS 코드는 백엔드 Node.js 애플리케이션과 연결을 위한 websocket을 엽니다. 관리자가 사이트에서 액션을 취하면 클라이언트 측 JS 코드가 백엔드로 메시지를 보냅니다.
1. 원장(ledger)을 읽거나 쓰는 것은 제안(proposal)이란 방법을 이용하는데, 이 제안은 `Marbles`(SDK를 통해)에서 작성된 다음 블록체인 `Peer`로 전송(queries)됩니다.
1. `Peer`는 `Marbles`의 체인코드 컨테이너와 통신합니다. 체인코드가 트랜잭션을 실행 및 테스트(run/simulate)한 후, 만약 어떤 문제가 없다면 그 트랜잭션을 승인하고 그 결과를 `Marbles` 애플리케이션으로 돌려 보냅니다.
1. `Marbles` 애플리케이션은 (SDK를 통해) 승인된 제안을 `Ordering Service`로 보낼 것이며, orderer는 수신한 여러 제안을 블록으로 패키징 한 다음, 네트워크의 peer에 새 블록을 브로드캐스트 합니다.
1. 최종적으로 `Peer`는 블록의 유효성을 확인하고 원장에 기록합니다. 이제 제안을 통한 트랜잭션이 적용되었으며 이후의 모든 요청에 이러한 변경 사항이 반영됩니다.

***

# Marbles Setup
설치가 끝날 때쯤에는 당신은 Hyperledger Fabric 전문가가 될 것이고, 스스로 설계(design)한 애플리케이션을 개발할 준비가 될 것입니다.

구슬 애플리케이션은 크게 3가지의 독립적인 파트로 구성됩니다.
  1. 블록체인 네트워크 (GoLang)
  2. Server Side (node.js)
  3. Client Side (Javascript 및 node.js)

### 코드 구조
이 애플리케이션에는 조정할 수 있는 3가지 코딩 환경이 있습니다.

1. 체인코드 파트 - 블록체인 네트워크의 peer와 함께 실행되는 GoLang 코드입니다. 또한 `cc` 라고도 부릅니다. 모든 구슬/블록체인 거래는 궁극적으로 체인코드에서 이루어집니다. 이 파일들은 `/chaincode`에 저장되어 있습니다.

1. **클라이언트** 사이드 JS 파트 - 사용자 브라우저에서 실행 중인 JavaScript코드입니다. UI 상호 작용은 여기서 발생합니다. 이 파일들은 `/public/js`에 저장되어 있습니다.

1. **서버** 사이드 JS 파트 - 애플리케이션의 백엔드를 실행하는 JavaScript코드입니다. 즉, `Node.js` 코드는 Marbles 예제의 심장 역할을 하고 있으며 `node` 또는 `server` 코드 라고도 합니다. marble 관리자와 블록체인 사이를 연결해주는 역할을 합니다. 이 파일들은 `/utils` 와 `/routes`에 저장되어 있습니다.

이 세 파트는 서로 분리되어 있다는 것을 기억하세요.
각 파트는 변수나 기능을 공유하지 않으며, gRPC, WebSockets, 또는 HTTP와 같은 네트워킹 프로토콜로 각각 통신합니다.

우리는 IBP([IBM Blockchain Platform](https://console.bluemix.net/developer/blockchain/dashboard)) 네트워크를 활용하여 오늘 실습을 진행할 것입니다. IBP 가 Hyperledger Fabric 기반인 만큼 우리는 1번 파트(블록체인 네트워크) 를 자신의 on-prem 환경에 구축할 수도 있습니다. 둘다 장/단점이 존재하며 on-prem 구성은 숙제로 남겨두겠습니다. 기억할 점은 1번, 2번, 3번 파트는 모두 독립적인 파트이기 때문에 어떤 블록체인 네트워트를 사용하던 간에 2번, 3번 파트는 동일하게 진행하면 된다는 것입니다.
### 실습1. [개발환경 구성하기](./실습1_개발환경_구성하기.md)
**Git**과 **Go**, **Node.js**를 설치하기 위해 [개발환경 구성하기](./실습1_개발환경_구성하기.md) 에 따라 컴퓨터 환경을 세팅합니다.
우리가 오늘 실습에서 사용할 프로그래밍 언어는 크게 GoLang 및 Node.js 입니다. (안타깝게도 프로그래밍 언어에 대한 설명은 이번 실습에서 진행하지 않습니다ㅠㅠ)

또한 우리는 IBP 를 블록체인 네트워크로 사용할 것이므로 이에 대한 사전 작업이 필요합니다. IBM Cloud 계정을 생성하고, IBP 서비스 생성을 무료로 하기 위한 권한을 획득하는 과정 등을 진행할 것입니다.

<a name="downloadmarbles"></a>

### 1. 구슬(Marbles) 애플리케이션 다운로드
로컬환경에 Marbles을 다운로드 받아야 합니다.
Git을 사용하여 이 저장소를 내려받습니다 (clone).
IBM Cloud에서 Marbles을 호스팅 하려는 경우에도 이 단계를 수행해야 합니다.

- 명령 프롬프트/터미널을 열고 원하는 작업 디렉토리로 이동합니다.
- 다음 명령을 실행합니다:

	```
	git clone https://github.com/IBM-Blockchain/marbles.git --depth 1
	cd marbles
	```

- 좋습니다. 2단계로 넘어갑니다.

<a name="getnetwork"></a>

### 2. 네트워크 연결
[실습2. IBM Blockchain Platform 시작하기](./실습2_IBM_Blockchain_Platform_시작하기.md)
이제 우리는 블록체인 네트워크가 필요합니다.
IBM Cloud, IBM Blockchain Service에 네트워크 생성 - [지침](./docs/use_bluemix_hyperledger.md)

<a name="installchaincode"></a>

### 3. 체인코드 설치 및 인스턴스화
[실습3-1. 체인코드 개발하기](./실습3-1_체인코드_개발하기.md)
[실습3-2. 체인코드 설치하기](./실습3-2_체인코드_설치하기.md)

좋아요, 거의 다 왔어요! 이제 우리는 구슬 애플리케이션의 체인코드를 실행할 필요가 있어요.
체인코드는 궁극적으로 원장에서 트랜잭션을 만드는 중요한 요소라는 것을 기억하세요.
체인코드는 GoLang 으로 작성된 코드로 우리의 peer 위에 설치하고 채널에서 인스턴스화 할 필요가 있습니다.
코드는 이미 작성되어 있고, 우리는 단지 그것을 실행시키기만 하면 됩니다.

- **Option 1:** IBM Blockchain Service에 체인코드 설치 및 인스턴스화 - [지침](./docs/install_chaincode.md)

<a name="hostmarbles"></a>

### 구슬 애플리케이션 호스팅
[실습4-1. 애플리케이션 구동](./실습4-1_애플리케이션_구동.md)

마지막으로 중요한 것은 우리는 어딘가에 구슬(marbles) 애플리케이션이 실행될 곳이 필요하다는 것입니다.

**아래 옵션 한가지를 선택하세요:**
- **Option 2:** :lollipop: 로컬에서 Marbles 호스팅 - [지침](./docs/host_marbles_locally.md)

***

<a name="use"></a>

# 구슬 애플리케이션(Marbles) 사용하기
[실습5. 애플리케이션 사용](./실습5_애플리케이션_사용.md)

1. 이 단계에서는 환경 설정, 블록체인 네트워크 생성, marbles 앱 및 체인코드가 실행되고 있어야 합니다. 그렇죠? 그렇지 않다면 위에서 진행한 내용을 다시 확인해주세요.
1. 축하합니다. 이제 marbles 애플리케이션을 충분히 다룰 수 있습니다 :)!
이것이 마지막 단계였습니다.

	![](/doc_images/use_marbles1.png)

실습을 진행하기에 앞서 

# 블록체인 배경지식
Marbles의 작동 방식에 대해 이야기하기 전에 Hyperleder Fabric의 흐름과 토폴로지에 대해 살펴보겠습니다.
먼저 몇가지 정의부터 알아봅시다.

### 용어 정의:

**Peer** - Peer는 블록체인 네트워크의 멤버로, Hyperledger Fabric을 실행하고 있습니다. marbles 예제 맥락에서 보면, Peer들은 특정 구슬 회사에 의해 소유되고 운영됩니다.

**CA** - CA(인증 기관)는 블록체인 네트워크의 게이트키핑(gatekeeping)을 담당합니다. 이것은 marbles 예제의 node.js 애플리케이션과 같이, 클라이언트 측의 트랜잭션이 유효한지 증명합니다.

**Orderer** - Orderer 또는 Ordering Service는 블록에 트랜잭션을 묶어서 일괄 처리하는 것이 주 목적인 블록체인 네트워크의 멤버입니다.

**Users** - User는 블록체인과 상호 작용할 수 있는 권한을 가진 하나의 주체(entity)입니다. Marbles 예제에서, User는 관리자(Admin)를 뜻합니다. User는 원장을 조회하거나 가록할 수 있습니다.

**Blocks** - 블록에는 무결성을 확인하기 위한 트랜잭션과 해시(hash)가 포함되어 있습니다.

**Transactions** or **Proposals** - 블록체인의 원장에 대한 상호 작용을 나타냅니다. 원장의 읽기 또는 쓰기 요청은 트랜잭션 또는 제안의 형태로 보내집니다.

**Ledger** - Peer가 블록체인에서 사용하는 저장소(storage)입니다. 여기에는 트랜잭션 파라미터와 key/value 쌍으로 구성된 실제 블록 데이터가 포함됩니다. 원장(Ledger)은 체인코드에 의해 기록됩니다.

**Chaincode** - 체인코드는 스마트 컨트랙트를 Hyperledger Fabric에서 칭하는 용어입니다. 자산(assets) 및 자산과 관련된 모든 규칙을 정의합니다.

**Assets** - 자산은 원장이 가지는 가치 또는 실체(entity)입니다. key/value 쌍으로 이뤄져 있으며, marbles 예제에서 자산은 구슬(marble) 또는 구슬의 소유자입니다.


이제 여러분은 모든 흐름을 알게 되었습니다.
관리자는 구슬을 움직였고, JS는 drag/drop을 감지했으며, 클라이언트는 웹소켓 메시지를 보내고, Marbles 애플리케이션은 웹소켓 메시지를 받습니다. SDK는 제안을 생성하거나 보내고, Peer는 제안를 승인합니다. SDK 정렬하기 위한 제안을 Orderer에게 보냅니다, Orderer는 정렬(패키징)하여 생성된 블록을 Peer에게 보냅니다, Peer는 블록을 커밋 합니다. node.js 코드는 주기적으로 새로운 구슬 상태를 얻습니다, 새로운 구슬 상태를 클라이언트에게 전달하면, 마침내 웹소켓 메시지를 받은 클라이언트는 새로운 구슬을 다시 그리게 됩니다.

네, 끝입니다! 구슬을 옮기면서 즐거운 시간 보내셨기를 바랍니다.

# FAQs
marbles에 대해 궁금한점이 있으면..

# Feedback
피드백은 언제나 환영합니다.
이 데모는 여러분과 같은 사람들을 위해 만들어진 데모입니다. 그리고 계속해서 개선될 것입니다.
데모에 개선할 수 있는 방법이 있으면 손을 뻗어 도와주세요!
구체적인 내용은 아래와 같습니다:

# Contribute
이 데모의 개선에 기여를 원하신다면 [contributing guide](./CONTRIBUTING.md)를 확인해주세요.

# License
[Apache 2.0](LICENSE)

***



