# IBM Blockchain Experience Day  
![intro.png](./doc_images/intro.png)  
  
# 실습0 : 실습 개요

********

## 실습 개요
- 본 실습은 [원문 Github](https://github.com/IBM-Blockchain/marbles/) 코드를 기반으로 작성되었으며, 효과적인 실습을 위해 설명의 추가, 소스코드 수정 등이 있음을 알려드립니다.
- 이 실습은 블록체인 기반 **구슬(Marbles) 교환 애플리케이션** 을 완성하는 것을 목표로 합니다.
- 이 애플리케이션은 Linux Foundation 프로젝트 [Hyperledger Fabric](https://github.com/hyperledger/fabric/tree/master/docs) 네트워크를 기반으로 한 실습입니다. Hyperledger Fabric 에 대한 이해를 높이기 위한 목적으로 작성되었습니다.
- 이 실습은 개발자가 Hyperledger Fabric 네트워크를 이용하여 스마트 컨트랙트(체인코드) 및 관련 앱 개발의 기본을 배울 수 있도록 도와줍니다.
- 이 실습에서 블록체인 네트워크는 **IBM Cloud 상의 IBM Blockchain Platform (IBP) 서비스를 이용하여 구성** 함을 가정하고 있습니다. 
- on-prem 서버 또는 VM 등에 Hyperledger Fabric 블록체인 네트워크 구성을 원하는 사용자는 [원문](https://github.com/IBM-Blockchain/marbles/) 을 참고하십시오. 또한 블록체인 네트워크의 구성 방법과 관계없이 [실습3]() 은 Hyperledger Fabric 스마트 컨트랙트(체인코드) 개발 방법을 배울 수 있는 실습입니다.
- 이 실습은 자산(asset, 실습에서는 구슬) 이 이동하는 것을 시연하였으며, 여러 사용자가 서로 자산을 만들어 전달할 수 있습니다.

	![](/doc_images/marbles-peek.gif)

## Hyperledger Fabric 버전
이 구슬(Marbles) 애플리케이션 실습은 **Hyperledger Fabric v1.2x** 와 호환됩니다.	

## 사전 요구 사항
- [IBM Cloud](https://console.bluemix.net/) 개인 계정
- IBM Blockchain Platform 서비스 무료 생성 권한 (IBM 담당자에게 계정 정보를 전달하면 권한을 획득할 수 있음)
- 실습 데스크탑 (IBM 담당자가 제공)
- 체인코드 개발서버 (IBM 담당자가 제공)
- _본 실습은 자신의 회사 또는 집에서 진행할 수 있습니다. 동일한 사전 환경을 구성하는데 ~~경우에 따라 아주 약간만 고생하면~~ 큰 어려움이 없습니다._

***

# 애플리케이션 설명

애플리케이션 이름은 **구슬(Marbles) 교환 애플리케이션** 입니다.  
우리는 이 애플리케이션을 통해 Hyperledger Fabric 을 이용하여 여러 구슬(marbles) 소유자들 간에 자산(marble) 이 이동하는 과정을 체험할 수 있습니다.

구슬이라는 자산은 조금은 유치해 보일 수 있지만,~~아니 엄청 유치~~ 이것은 생각에 따라 다이아몬드가 될 수도, 중고물품이 될 수도, 무형의 가치가 될 수도 있습니다. 자산을 거래한다는 관점에서 본 실습을 성실히 학습한다면 기초를 쌓는데 큰 도움이 될 것입니다.

이 애플리케이션은 GoLang 과 Node.js 로 구현되었습니다.  
백엔드 부문, 즉 스마트 컨트랙트 부문은 GoLang 으로 구현된 코드가 블록체인 네트워크에서 실행됩니다. Hyperledger Fabric 프로젝트에서 스마트 컨트랙트는 체인코드(Chaincode) 라고 특별히 부른다는 것을 기억하십시오. 따라서 지금부터는 GoLang 으로 구현된 스마트 컨트랙트 코드를 '체인코드(chaincode)' 또는 'cc'로 부르도록 하겠습니다.

체인코드는 GoLang 뿐만 아니라 node.js, JAVA 로도 개발할 수 있습니다.(2019.02 기준) 그러나 현재까지는 GoLang 이 가장 안정적이며 많은 reference 를 갖고 있으므로 우리 실습에서도 GoLang 프로그래밍 언어를 활용하여 체인코드를 개발하겠습니다. (~~Fabric 이 GoLang 으로 개발..~~)
체인코드는 자체적으로 체인코드 상태를 기록(저장)하여 구슬(marble) 을 만들며, key/value 문자열 쌍을 데이터로 저장합니다.
따라서, 체인코드에는 다양한 구조의 데이터를 저장할 수 있도록 JSON 형식으로 변환(stringify)되어 저장됩니다.

구슬(marble) 데이터 속성:

  1. id (unique string, 키 값으로 사용되는 유니크한 문자)
  2. color (string, 구슬의 css 색상 값)
  3. size (int, 구슬 크기)
  4. owner (string, 소유자명)

우리는 위의 값들을 설정하고, 사고 팔 수 있는(정확히는 주고 받을 수 있는) UI 를 만들어 블록체인의 원장에 저장할 예정입니다.  
구슬(marble) 은 `key`와 `value` 쌍으로 이루어져 있으며, `key`는 블록체인 원장에 구슬을 기록할 때 사용되는 고유한 구슬(자산) 의 ID 이고, `value`는 구슬(marble) 의 속성을 담고 있는 JSON 문자열입니다.

즉 위에서 나열되었던 4개의 데이터 속성이 모두 'value' 에 해당합니다.  
체인코드(cc)는 gRPC 프로토콜을 이용하여 네트워크의 peer로 접속되어 상호작용합니다. gRPC 프로토콜에 대한 상세 내용은 [Hyperledger Fabric Client](https://www.npmjs.com/package/fabric-client) 라고 불리는 SDK에서 확인할 수 있습니다.  
토폴로지에 대한 상세 내용은 아래 그림을 참고하십시오.

### 애플리케이션 통신 흐름

![](/doc_images/comm_flow.png)

1. 관리자는 브라우저에서 Node.js으로 구현된 애플리케이션을 통해 Marble들을 관리할 것입니다.
2. 이 클라이언트 측 JS 코드는 백엔드 Node.js 애플리케이션과 연결을 위한 websocket을 엽니다. 관리자가 사이트에서 액션을 취하면 클라이언트 측 JS 코드가 백엔드로 메시지를 보냅니다.
3. 원장(ledger)을 읽거나 쓰는 것은 제안(proposal)이란 방법을 이용하는데, 이 제안은 `Marbles`(SDK를 통해)에서 작성된 다음 블록체인 `Peer`로 전송(queries)됩니다.
4. `Peer`는 `Marbles`의 체인코드 컨테이너와 통신합니다. 체인코드가 트랜잭션을 실행 및 테스트(run/simulate)한 후, 만약 어떤 문제가 없다면 그 트랜잭션을 승인하고 그 결과를 `Marbles` 애플리케이션으로 돌려 보냅니다.
5. `Marbles` 애플리케이션은 (SDK를 통해) 승인된 제안을 `Ordering Service`로 보낼 것이며, orderer는 수신한 여러 제안을 블록으로 패키징 한 다음, 네트워크의 peer에 새 블록을 브로드캐스트 합니다.
6. 최종적으로 `Peer`는 블록의 유효성을 확인하고 원장에 기록합니다. 이제 제안을 통한 트랜잭션이 적용되었으며 이후의 모든 요청에 이러한 변경 사항이 반영됩니다.

***

# 실습 과정에 대하여
모든 실습을 완료할 때쯤에는 당신은 Hyperledger Fabric 설치 및 관련 애플리케이션 개발에 대한 1 Cycle 을 경험할 것이며, 스스로 설계(design)한 애플리케이션을 개발할 준비가 될 것입니다.

이 실습에서 개발할 구슬 애플리케이션은 크게 3가지의 독립적인 파트로 구성됩니다.
  1. 블록체인 네트워크 (GoLang)
  2. Server Side (node.js)
  3. Client Side (Javascript 및 node.js)

### 코드
이 애플리케이션에는 조정할 수 있는 3가지 코딩 환경이 있습니다.

1. 체인코드 파트 - 블록체인 네트워크의 peer와 함께 실행되는 GoLang 코드입니다. 또한 `cc` 라고도 부릅니다. 모든 구슬/블록체인 거래는 궁극적으로 체인코드에서 이루어집니다. 이 파일들은 `/chaincode`에 저장되어 있습니다.

2. **클라이언트** 사이드 JS 파트 - 사용자 브라우저에서 실행 중인 JavaScript코드입니다. UI 상호 작용은 여기서 발생합니다. 이 파일들은 `/public/js`에 저장되어 있습니다.

3. **서버** 사이드 JS 파트 - 애플리케이션의 백엔드를 실행하는 JavaScript코드입니다. 즉, `Node.js` 코드는 Marbles 예제의 심장 역할을 하고 있으며 `node` 또는 `server` 코드 라고도 합니다. marble 관리자와 블록체인 사이를 연결해주는 역할을 합니다. 이 파일들은 `/utils` 와 `/routes`에 저장되어 있습니다.

이 세 파트는 서로 분리되어 있다는 것을 기억하세요.  
각 파트는 변수나 기능을 공유하지 않으며, gRPC, WebSockets, 또는 HTTP와 같은 네트워킹 프로토콜로 각각 통신합니다.

우리는 [IBM Blockchain Platform](https://console.bluemix.net/developer/blockchain/dashboard)(이하 IBP) 네트워크를 활용하여 오늘 실습을 진행할 것입니다.  
IBP 가 Hyperledger Fabric 기반인 만큼 우리는 1번 파트(블록체인 네트워크) 를 자신의 on-prem 환경에 구축할 수도 있습니다. 장/단점이 존재하며 on-prem 구성은 본 실습에서는 생략하겠습니다.~~지 멋대로 생략..~~

기억할 점은 1번, 2번, 3번 파트는 모두 독립적인 파트이기 때문에 어떤 블록체인 네트워트를 사용하던 간에 1번을 제외한 2번, 3번 파트는 동일하게 진행하면 된다는 것입니다.

우리는 다음의 과정으로 실습을 진행합니다.

### [실습1. 실습환경 구성](./실습1_개발환경_구성.md)
**Git**과 **Go**, **Node.js**를 설치하기 위해 [개발환경 구성하기](./실습1_개발환경_구성하기.md) 에 따라 컴퓨터 환경을 세팅합니다.
우리가 오늘 실습에서 사용할 프로그래밍 언어는 크게 GoLang 및 Node.js 입니다. (안타깝게도 프로그래밍 언어에 대한 설명은 이번 실습에서 진행하지 않습니다ㅠㅠ)

또한 우리는 IBP 를 블록체인 네트워크로 사용할 것이므로 이에 대한 사전 작업이 필요합니다. IBM Cloud 계정을 생성하고, IBP 서비스 생성을 무료로 하기 위한 권한을 획득하는 과정 등을 진행할 것입니다.


### [실습2. 블록체인 생성](./실습2_블록체인_생성.md)
우리는 블록체인 네트워크가 ~~당연히~~ 필요합니다.
Hyperledger Fabric 블록체인 네트워크를 설치하는 방법은 크게 3가지 방법으로 나눌 수 있겠습니다.

1. 개인 또는 회사의 local 서버에 직접 설치
2. 클라우드 VM 서버에 설치 (~~아마존 AWS 도 좋지만 IBM Cloud VM 도 좀..~~
3. IBM Blockchain Platform 서비스 사용

우리는 3번 방법을 통해 실습을 진행합니다.

### 3. [실습3. 체인코드 개발](./실습3_체인코드_개발.md)
체인코드를 개발하는 것이 블록체인 개발자의 핵심 역량이겠죠? 우리는 본 실습에서 긴 시간을 투자해 Hyperledger Fabric 에 설치할 스마트 컨트랙트를 개발하는 방법에 대해 배울 것입니다.

### 4. [실습3. 체인코드 구동](./실습4_체인코드_구동.md)
좋아요, 거의 다 왔어요! 이제 우리는 구슬 애플리케이션의 체인코드를 실행할 필요가 있어요.
체인코드는 궁극적으로 원장에서 트랜잭션을 만드는 중요한 요소라는 것을 기억하세요.
체인코드는 GoLang 으로 작성된 코드로 우리의 peer 위에 설치하고 채널에서 인스턴스화 할 필요가 있습니다.
코드는 이미 작성되어 있고, 우리는 단지 그것을 실행시키기만 하면 됩니다.
- **Option 1:** IBM Blockchain Service에 체인코드 설치 및 인스턴스화 - [지침](./docs/install_chaincode.md)

### 5. [실습5. 애플리케이션 개발 및 구동](./실습5_애플리케이션_개발_및_구동.md)
블록체인 환경을 모두 구성했다면 이제 그것을 사용할 애플리케이션이 필요합니다. 애플리케이션을 짜는 것은 개발자 마음이지만, 적어도 블록체인 원장의 데이터와 통신할 SDK 의 사용방법에 대해서는 숙지해야 합니다.  

SDK 에 대한 자세한 내용 및 애플리케이션 부문 코드 개발에 대한 자세한 내용은 본 실습에서 생략합니다. 다만 우리는 완성되어 있는 코드를 검토하고, 구동하는 실습을 진행할 것입니다.

마지막으로 중요한 것은 우리는 어딘가에 구슬(marbles) 애플리케이션이 실행될 곳이 필요하다는 것입니다.
우리는 구슬 애플리케이션을 자신의 PC 에 설치할 것입니다.
**Option 2:** :lollipop: 로컬에서 Marbles 호스팅 - [지침](./docs/host_marbles_locally.md)

***

1. 이 단계에서는 환경 설정, 블록체인 네트워크 생성, marbles 앱 및 체인코드가 실행되고 있어야 합니다. 그렇죠? 그렇지 않다면 위에서 진행한 내용을 다시 확인해주세요.
1. 축하합니다. 이제 marbles 애플리케이션을 충분히 다룰 수 있습니다 :)!
이것이 마지막 단계였습니다.

	![](/doc_images/use_marbles1.png)



# 참고: 블록체인 배경지식
Marbles의 작동 방식에 대해 이야기하기 전에 Hyperleder Fabric의 흐름과 토폴로지에 대해 살펴보겠습니다.
먼저 몇가지 정의부터 알아봅시다.

### 용어 정의:

**Peer** - Peer는 블록체인 네트워크의 멤버로, Hyperledger Fabric을 실행하고 있습니다. marbles 예제 맥락에서 보면, Peer들은 특정 구슬 회사에 의해 소유되고 운영됩니다.

**CA** - CA(인증 기관)는 블록체인 네트워크의 게이트키핑(gatekeeping)을 담당합니다. 이것은 marbles 예제의 node.js 애플리케이션과 같이, 클라이언트 측의 트랜잭션이 유효한지 증명합니다.

**Orderer** - Orderer 또는 Ordering Service는 블록에 트랜잭션을 묶어서 일괄 처리하는 것이 주 목적인 블록체인 네트워크의 멤버입니다.

**Users** - User는 블록체인과 상호 작용할 수 있는 권한을 가진 하나의 주체(entity)입니다. Marbles 예제에서, User는 관리자(Admin)를 뜻합니다. User는 원장을 조회하거나 가록할 수 있습니다.

**Blocks** - 블록에는 무결성을 확인하기 위한 트랜잭션과 해시(hash)가 포함되어 있습니다.

**Transactions** or **Proposals** - 블록체인의 원장에 대한 상호 작용을 나타냅니다. 원장의 읽기 또는 쓰기 요청은 트랜잭션 또는 제안의 형태로 보내집니다.

**Ledger** - Peer가 블록체인에서 사용하는 저장소(storage)입니다. 여기에는 트랜잭션 파라미터와 key/value 쌍으로 구성된 실제 블록 데이터가 포함됩니다. 원장(Ledger)은 체인코드에 의해 기록됩니다.

**Chaincode** - 체인코드는 스마트 컨트랙트를 Hyperledger Fabric에서 칭하는 용어입니다. 자산(assets) 및 자산과 관련된 모든 규칙을 정의합니다.

**Assets** - 자산은 원장이 가지는 가치 또는 실체(entity)입니다. key/value 쌍으로 이뤄져 있으며, marbles 예제에서 자산은 구슬(marble) 또는 구슬의 소유자입니다.


네, 끝입니다! 구슬을 옮기면서 즐거운 시간 보내셨기를 바랍니다.

# FAQs
marbles에 대해 궁금한점이 있으면..

# Feedback
피드백은 언제나 환영합니다.
이 데모는 여러분과 같은 사람들을 위해 만들어진 데모입니다. 그리고 계속해서 개선될 것입니다.
데모에 개선할 수 있는 방법이 있으면 손을 뻗어 도와주세요!
구체적인 내용은 아래와 같습니다:

# Contribute
이 데모의 개선에 기여를 원하신다면 [contributing guide](./CONTRIBUTING.md)를 확인해주세요.

# License
[Apache 2.0](LICENSE)

***
